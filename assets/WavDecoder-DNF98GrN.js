(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const a of i.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&s(a)}).observe(document,{childList:!0,subtree:!0});function e(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(r){if(r.ep)return;r.ep=!0;const i=e(r);fetch(r.href,i)}})();const nt={1:"PCM",3:"IEEE Float",6:"A-Law",7:"Âµ-Law",65534:"Extensible"};var m=(o=>(o[o.DECODING=0]="DECODING",o[o.ENDED=1]="ENDED",o[o.ERROR=2]="ERROR",o[o.IDLE=3]="IDLE",o))(m||{});class z{capacity;mask;buffer;writePos=0;readPos=0;size=0;constructor(t){if((t&t-1)!==0||t<2)throw new Error("Capacity must be a power of two and at least 2");this.capacity=t,this.mask=t-1,this.buffer=new Uint8Array(t)}get available(){return this.size}write(t){const e=t.length;if(e===0)return 0;const s=this.capacity-this.size;if(s===0)return 0;const r=e>s?s:e,i=this.writePos,a=this.buffer,n=this.capacity-i;return r<=n?a.set(t.subarray(0,r),i):(a.set(t.subarray(0,n),i),a.set(t.subarray(n,r),0)),this.writePos=i+r&this.mask,this.size+=r,r}readInto(t){const e=t.length;if(e===0)return!0;if(this.size<e)return!1;const s=this.readPos,r=this.buffer,i=this.capacity-s;return e<=i?t.set(r.subarray(s,s+e),0):(t.set(r.subarray(s,s+i),0),t.set(r.subarray(0,e-i),i)),this.readPos=s+e&this.mask,this.size-=e,!0}read(t){if(this.size<t)return null;const e=new Uint8Array(t);return this.readInto(e),e}clear(){this.writePos=0,this.readPos=0,this.size=0}discard(t){t>this.size&&(t=this.size),this.readPos=this.readPos+t&this.mask,this.size-=t}peekContiguous(){const t=this.readPos,e=Math.min(this.size,this.capacity-t);return this.buffer.subarray(t,t+e)}peek(t,e=0){const s=this.readPos+e&this.capacity-1,r=s+t&this.capacity-1;return s<r||r===0?this.buffer.subarray(s,s+t):this.buffer.subarray(0,r)}}const D=6,$=65534,B=3,L=7,S=1,p=17,O=1/128,y=1/32768,A=1/8388608,P=1/2147483648,U=1380533830,V=1380533848,W=1463899717,_=1718449184,X=1684108385,G=1717658484;function F(o,t,e,s,r=i=>i){let i=0;for(;i+4<=e;i+=4)t[i]=r(o[i])*s,t[i+1]=r(o[i+1])*s,t[i+2]=r(o[i+2])*s,t[i+3]=r(o[i+3])*s;for(;i<e;++i)t[i]=r(o[i])*s}function T(o,t,e,s,r,i=a=>a){let a=0,n=0;for(;a+4<=s;a+=4,n+=8)t[a]=i(o[n])*r,e[a]=i(o[n+1])*r,t[a+1]=i(o[n+2])*r,e[a+1]=i(o[n+3])*r,t[a+2]=i(o[n+4])*r,e[a+2]=i(o[n+5])*r,t[a+3]=i(o[n+6])*r,e[a+3]=i(o[n+7])*r;for(;a<s;++a,n+=2)t[a]=i(o[n])*r,e[a]=i(o[n+1])*r}function k(o,t){return(o[t+2]<<16|o[t+1]<<8|o[t])<<8>>8}function v(o,t,e){F(o,t,e,O,s=>s-128)}function H(o,t,e,s){T(o,t,e,s,O,r=>r-128)}function q(o,t,e){F(o,t,e,y)}function Z(o,t,e,s){T(o,t,e,s,y)}function K(o,t,e){let s=0,r=0;for(;s+4<=e;s+=4,r+=12)for(let i=0;i<4;++i)t[s+i]=k(o,r+i*3)*A;for(;s<e;++s,r+=3)t[s]=k(o,r)*A}function Y(o,t,e,s){let r=0,i=0;for(;r+4<=s;r+=4,i+=24)for(let a=0;a<4;++a){const n=i+a*6;t[r+a]=k(o,n)*A,e[r+a]=k(o,n+3)*A}for(;r<s;++r,i+=6)t[r]=k(o,i)*A,e[r]=k(o,i+3)*A}function j(o,t,e){F(o,t,e,P)}function J(o,t,e,s){T(o,t,e,s,P)}function Q(o,t,e){F(o,t,e,1)}function tt(o,t,e,s){T(o,t,e,s,1)}const w=new Set([S,B,D,L,p]),et=new Map([[S,[8,16,24,32]],[B,[32,64]],[D,[8]],[L,[8]],[p,[4]]]),st=new Uint8Array([3,0,0,0,0,0,16,0,128,0,0,170,0,56,155,113]),rt=new Uint8Array([1,0,0,0,0,0,16,0,128,0,0,170,0,56,155,113]);let R=null,I=null;function x(){if(!R){R=new Float32Array(256);for(let o=0;o<256;o++){let t=o^85,e=t&128?-1:1,s=(t&112)>>4,r=t&15,i;s===0?i=(r<<4)+8:i=(r+16<<s+3)-2048,R[o]=e*i*y}}return R}function N(){if(!I){I=new Float32Array(256);for(let t=0;t<256;t++){let e=~t&255,s=e&128?-1:1,r=(e&112)>>4,a=((e&15)<<3)+132<<r;a-=132,I[t]=s*a*y}}return I}const it=new Int32Array([7,8,9,10,11,12,13,14,16,17,19,21,23,25,28,31,34,37,41,45,50,55,60,66,73,80,88,97,107,118,130,143,157,173,190,209,230,253,279,307,337,371,408,449,494,544,598,658,724,796,876,963,1060,1166,1282,1411,1552,1707,1878,2066,2272,2499,2749,3024,3327,3660,4026,4428,4871,5358,5894,6484,7132,7845,8630,9493,10442,11487,12635,13899,15289,16818,18500,20350,22385,24623,27086,29794,32767]),at=new Int8Array([-1,-1,-1,-1,2,4,6,8,-1,-1,-1,-1,2,4,6,8]);class M{static MAX_BUFFER_SIZE=16*1024*1024;static MAX_CHANNELS=32;static MAX_HEADER_SIZE=2*1024*1024;static MAX_SAMPLE_RATE=384e3;dataStartOffset=0;bytesPerSample=0;channelData=[];decodeBuffer;scratchPool=[];decodedBytes=0;errors=[];factChunkSamples=0;format={};formatTag=0;headerBuffer=new Uint8Array(0);isLittleEndian=!0;parsedChunks=[];remainingBytes=0;ringBuffer;state=m.IDLE;totalBytes=0;unhandledChunks=[];decoderLookup={};errorTemplate={frameLength:0,frameNumber:0,inputBytes:0,message:"",outputSamples:0};constructor(t={}){const e=t.bufferSize??M.MAX_BUFFER_SIZE;this.ringBuffer=new z(e),this.decodeBuffer=this.getScratchBuffer(4096),this.initDecoderLookup()}get estimatedSamples(){return this.factChunkSamples>0?this.factChunkSamples:this.totalBytes>0&&this.format.blockAlign>0?this.formatTag===p?Math.floor(this.totalBytes/this.format.blockAlign)*(this.format.samplesPerBlock??0):Math.floor(this.totalBytes/this.format.blockAlign):0}get info(){return{decodedBytes:this.decodedBytes,errors:[...this.errors],format:{...this.format},parsedChunks:[...this.parsedChunks],remainingBytes:this.remainingBytes,state:this.state,totalBytes:this.totalBytes,unhandledChunks:[...this.unhandledChunks]}}get progress(){return this.totalBytes>0?this.decodedBytes/this.totalBytes:0}get totalDuration(){return this.estimatedSamples/(this.format.sampleRate||1)}static supports(t){return w.has(t)}decode(t){if(this.state===m.ENDED||this.state===m.ERROR)return this.createErrorResult("Decoder is in a terminal state.");try{if(this.state===m.IDLE){if(this.headerBuffer.length+t.length>M.MAX_HEADER_SIZE)return this.state=m.ERROR,this.createErrorResult("Header size exceeds maximum limit.");const e=new Uint8Array(this.headerBuffer.length+t.length);if(e.set(this.headerBuffer,0),e.set(t,this.headerBuffer.length),this.headerBuffer=e,this.tryParseHeader(),this.state===m.IDLE)return this.createEmptyResult();if(this.state===m.ERROR)return{bitsPerSample:this.format.bitsPerSample,channelData:[],errors:[...this.errors],sampleRate:0,samplesDecoded:0}}else if(this.ringBuffer.write(t)<t.length)return this.state=m.ERROR,this.createErrorResult("Audio buffer capacity exceeded.");return this.processBufferedBlocks()}catch(e){this.state=m.ERROR;const s=e instanceof Error?e.message:String(e);return this.errors.push(this.createError(`Decode error: ${s}`)),this.createErrorResult("Decode error")}}decodeFrame(t){if(this.state!==m.DECODING)throw new Error("Decoder is not in the DECODING state.");if(t.length!==this.format.blockAlign)throw new Error(`Invalid frame length: received ${t.length}, expected ${this.format.blockAlign}.`);if(this.formatTag===p)throw new Error("decodeFrame() is not supported for IMA ADPCM format.");const{channels:e,bitsPerSample:s}=this.format,r=new Float32Array(e),i=new DataView(t.buffer,t.byteOffset,t.length),a=s/8;for(let n=0;n<e;n++){const h=n*a;r[n]=this.readSample(i,h,s,this.formatTag)}return r}decodeFrames(t){if(this.state!==m.DECODING)return this.createErrorResult("Decoder must be initialized before decodeFrames().");if(t.length===0)return this.createEmptyResult();const e=t.reduce((i,a)=>i+a.length,0);if(this.format.blockAlign<=0||e%this.format.blockAlign!==0)return this.createErrorResult("Total bytes of frames must be a multiple of the `frameLength` (blockAlign).");const s=new Uint8Array(e);let r=0;for(const i of t)s.set(i,r),r+=i.length;try{const i=this.decodeInterleavedFrames(s);return this.decodedBytes+=s.length,this.remainingBytes=Math.max(0,this.remainingBytes-s.length),i}catch(i){this.state=m.ERROR;const a=i instanceof Error?i.message:String(i);return this.errors.push(this.createError(`Block decode error: ${a}`)),this.createErrorResult("Block decode error")}}flush(){if(this.state===m.ENDED||this.state===m.ERROR)return this.createEmptyResult();const t=this.processBufferedBlocks(),e=this.ringBuffer.available;if(e>0){const r=this.createError(`Discarded ${e} bytes of incomplete final block.`);this.errors.push(r),this.remainingBytes=Math.max(0,this.remainingBytes-e),this.ringBuffer.clear()}this.state=m.ENDED;const s=[...t.errors,...this.errors];return this.errors.length=0,t.samplesDecoded>0?{...t,errors:s}:{bitsPerSample:this.format.bitsPerSample||0,channelData:[],errors:s,sampleRate:this.format.sampleRate||0,samplesDecoded:0}}free(){this.releaseScratchBuffer(this.decodeBuffer),this.scratchPool=[],this.reset(),this.state=m.ENDED}reset(){this.state=m.IDLE,this.ringBuffer.clear(),this.errors.length=0,this.format={},this.remainingBytes=this.decodedBytes=this.totalBytes=this.factChunkSamples=0,this.parsedChunks=[],this.unhandledChunks=[],this.formatTag=0,this.isLittleEndian=!0,this.headerBuffer=new Uint8Array(0),this.channelData=[],this.dataStartOffset=0}seekSeconds(t){if(this.state!==m.DECODING)throw new Error("Decoder must be in DECODING state to seek.");if(!this.format.sampleRate||!this.format.blockAlign||!this.dataStartOffset)throw new Error("WAV header not fully parsed.");const e=this.format.sampleRate,s=this.format.blockAlign,r=this.dataStartOffset,i=Math.max(0,t),a=Math.max(0,Math.floor(i*e));let n;if(this.formatTag===p){const b=this.format.samplesPerBlock,E=Math.floor(this.totalBytes/s),C=this.factChunkSamples>0?this.factChunkSamples:E*b;n=Math.max(0,C)}else n=Math.floor(this.totalBytes/s);const h=n>0?Math.min(a,n-1):0;let l,d,c=0,f=0;if(this.formatTag===p){const b=this.format.samplesPerBlock;if(!b||b<=0)throw new Error("IMA ADPCM: missing samplesPerBlock");const E=Math.floor(h/b);d=E*b,f=h-d,l=r+E*s}else d=h,l=r+h*s;const u=d+c+f;return{byteOffset:l,nativeSampleRate:e,requestedTime:i,anchorSample:d,prerollSamples:c,discardSamples:f,firstAudibleSample:u,isExact:u===a}}initDecoderLookup(){this.decoderLookup={[S]:{1:{8:this.decodePCM8Mono.bind(this),16:this.decodePCM16Mono.bind(this),24:this.decodePCM24Mono.bind(this),32:this.decodePCM32Mono.bind(this)},2:{8:this.decodePCM8Stereo.bind(this),16:this.decodePCM16Stereo.bind(this),24:this.decodePCM24Stereo.bind(this),32:this.decodePCM32Stereo.bind(this)}},[B]:{1:{32:this.decodeFloat32Mono.bind(this)},2:{32:this.decodeFloat32Stereo.bind(this)}}}}decodeInterleavedFrames(t){const{blockAlign:e,channels:s,sampleRate:r,bitsPerSample:i}=this.format;let a;if(this.formatTag===p){const{samplesPerBlock:f}=this.format;if(!f)return this.createErrorResult("Missing samplesPerBlock for IMA ADPCM");a=t.length/e*f}else a=t.length/e;this.initChannelData(s,a);const n=new DataView(t.buffer,t.byteOffset,t.byteLength),h=this.decoderLookup[this.formatTag]?.[s]?.[i];h?h(n,a):this.decodeGeneric(n,a);const l=this.formatTag===p?16:i,d=this.channelData.map(f=>f.subarray(0,a)),c=[...this.errors];return this.errors.length=0,{bitsPerSample:l,channelData:d,errors:c,sampleRate:r,samplesDecoded:a}}decodeGeneric(t,e){switch(this.formatTag){case S:this.decodeGenericPCM(t,e,this.bytesPerSample,this.format.bitsPerSample);break;case B:this.decodeFloat(t,e,this.bytesPerSample,this.format.bitsPerSample);break;case D:case L:this.decodeCompressed(t,e);break;case p:this.decodeImaAdpcm(t,e);break;default:this.channelData.forEach(s=>s.fill(0))}}decodePCM8Mono(t,e){const s=this.channelData[0],r=new Uint8Array(t.buffer,t.byteOffset,e);v(r,s,e)}decodePCM8Stereo(t,e){const s=this.channelData[0],r=this.channelData[1],i=new Uint8Array(t.buffer,t.byteOffset,e*2);H(i,s,r,e)}decodePCM16Mono(t,e){const s=this.channelData[0];if(this.isLittleEndian){const r=new Int16Array(t.buffer,t.byteOffset,e);q(r,s,e)}else for(let r=0;r<e;r++)s[r]=t.getInt16(r*2,!1)*y}decodePCM16Stereo(t,e){const s=this.channelData[0],r=this.channelData[1];if(this.isLittleEndian){const i=new Int16Array(t.buffer,t.byteOffset,e*2);Z(i,s,r,e)}else for(let i=0;i<e;i++){const a=i*4;s[i]=t.getInt16(a,!1)*y,r[i]=t.getInt16(a+2,!1)*y}}decodePCM24Mono(t,e){const s=this.channelData[0];if(this.isLittleEndian){const r=new Uint8Array(t.buffer,t.byteOffset,e*3);K(r,s,e)}else{const r=new Uint8Array(t.buffer,t.byteOffset,e*3);let i=0;for(let a=0;a<e;a++){let n=r[i]<<16|r[i+1]<<8|r[i+2];n=n<<8>>8,s[a]=n*A,i+=3}}}decodePCM24Stereo(t,e){const s=this.channelData[0],r=this.channelData[1];if(this.isLittleEndian){const i=new Uint8Array(t.buffer,t.byteOffset,e*6);Y(i,s,r,e)}else{const i=new Uint8Array(t.buffer,t.byteOffset,e*6);let a=0;for(let n=0;n<e;n++){let h=i[a]<<16|i[a+1]<<8|i[a+2];h=h<<8>>8,s[n]=h*A,a+=3;let l=i[a]<<16|i[a+1]<<8|i[a+2];l=l<<8>>8,r[n]=l*A,a+=3}}}decodePCM32Mono(t,e){const s=this.channelData[0];if(this.isLittleEndian){const r=new Int32Array(t.buffer,t.byteOffset,e);j(r,s,e)}else for(let r=0;r<e;r++)s[r]=t.getInt32(r*4,!1)*P}decodePCM32Stereo(t,e){const s=this.channelData[0],r=this.channelData[1];if(this.isLittleEndian){const i=new Int32Array(t.buffer,t.byteOffset,e*2);J(i,s,r,e)}else for(let i=0;i<e;i++){const a=i*8;s[i]=t.getInt32(a,!1)*P,r[i]=t.getInt32(a+4,!1)*P}}decodeFloat32Mono(t,e){const s=this.channelData[0];if(this.isLittleEndian)Q(new Float32Array(t.buffer,t.byteOffset,e),s,e);else for(let r=0;r<e;r++)s[r]=Math.max(-1,Math.min(1,t.getFloat32(r*4,!1)))}decodeFloat32Stereo(t,e){const s=this.channelData[0],r=this.channelData[1];if(this.isLittleEndian)tt(new Float32Array(t.buffer,t.byteOffset,e*2),s,r,e);else for(let i=0;i<e;i++){const a=i*8;s[i]=Math.max(-1,Math.min(1,t.getFloat32(a,!1))),r[i]=Math.max(-1,Math.min(1,t.getFloat32(a+4,!1)))}}validateFormat(){const{bitsPerSample:t,channels:e,sampleRate:s}=this.format;return t===0||e===0||s===0?(this.errors.push(this.createError("Invalid format: zero values in required fields")),!1):e>M.MAX_CHANNELS?(this.errors.push(this.createError(`Too many channels: ${e} (max ${M.MAX_CHANNELS})`)),!1):s>M.MAX_SAMPLE_RATE?(this.errors.push(this.createError(`Sample rate too high: ${s} (max ${M.MAX_SAMPLE_RATE})`)),!1):w.has(this.formatTag)?et.get(this.formatTag)?.includes(t)?this.validateBlockAlignment():(this.errors.push(this.createError(`Invalid bit depth: ${t} for format 0x${this.formatTag.toString(16)}`)),!1):(this.errors.push(this.createError(`Unsupported audio format: 0x${this.formatTag.toString(16)}`)),!1)}validateBlockAlignment(){if(this.formatTag===p)return this.validateImaAdpcmFormat();const t=this.format.bitsPerSample/8*this.format.channels;this.format.blockAlign!==t&&t>0&&(this.errors.push(this.createError(`Corrected invalid blockAlign: header value was ${this.format.blockAlign}, but is now ${t}`)),this.format.blockAlign=t);const e=this.format.sampleRate*this.format.blockAlign;return this.format.avgBytesPerSec!==e&&e>0&&(this.errors.push(this.createError(`Corrected invalid byteRate: header value was ${this.format.avgBytesPerSec}, but is now ${e}`)),this.format.avgBytesPerSec=e),!0}validateImaAdpcmFormat(){if(!this.format.samplesPerBlock||this.format.samplesPerBlock<1)return this.errors.push(this.createError("Missing or invalid samplesPerBlock for IMA ADPCM")),!1;const{channels:t,samplesPerBlock:e}=this.format,s=4*t+Math.ceil((e-1)*t/2);this.format.blockAlign!==s&&(this.errors.push(this.createError(`Corrected invalid blockAlign for IMA ADPCM: was ${this.format.blockAlign}, now ${s}`)),this.format.blockAlign=s);const r=Math.ceil(this.format.sampleRate*this.format.blockAlign/e);return this.format.avgBytesPerSec!==r&&(this.errors.push(this.createError(`Corrected invalid byteRate for IMA ADPCM: was ${this.format.avgBytesPerSec}, now ${r}`)),this.format.avgBytesPerSec=r),!0}getScratchBuffer(t){if(this.scratchPool.length>0){const e=this.scratchPool.pop();if(e.byteLength>=t)return e}return new ArrayBuffer(t)}releaseScratchBuffer(t){this.scratchPool.push(t)}initChannelData(t,e){this.channelData.length===t&&this.channelData[0].length>=e||(this.channelData=Array.from({length:t},()=>new Float32Array(e)))}arraysEqual(t,e){if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(t[s]!==e[s])return!1;return!0}createError(t){const e=this.format.blockAlign??0,s={...this.errorTemplate};return s.frameLength=e,s.frameNumber=e>0?Math.floor(this.decodedBytes/e):0,s.inputBytes=this.decodedBytes,s.message=t,s.outputSamples=this.estimatedSamples,s}createEmptyResult(){const t=[...this.errors];return this.errors.length=0,{bitsPerSample:this.format.bitsPerSample,channelData:[],errors:t,sampleRate:this.format.sampleRate,samplesDecoded:0}}createErrorResult(t){return this.errors.push(this.createError(t)),this.createEmptyResult()}decodeCompressed(t,e){const s=this.format.channels,r=this.format.blockAlign,i=this.formatTag===D?x():N(),a=new Uint8Array(t.buffer,t.byteOffset,t.byteLength);for(let n=0;n<e;n++){const h=n*r;for(let l=0;l<s;l++){const d=h+l;this.channelData[l][n]=i[a[d]]}}}decodeFloat(t,e,s,r){const i=this.format.channels,a=this.format.blockAlign,n=r===64;for(let h=0;h<e;h++){const l=h*a;for(let d=0;d<i;d++){const c=l+d*s;let f;n?f=t.getFloat64(c,this.isLittleEndian):f=t.getFloat32(c,this.isLittleEndian),this.channelData[d][h]=Math.max(-1,Math.min(1,f))}}}decodeGenericPCM(t,e,s,r){const i=this.format.channels;let a=0;for(let n=0;n<e;n++)for(let h=0;h<i;h++){if(a+s>t.byteLength){this.channelData[h][n]=0;continue}this.channelData[h][n]=this.readPcm(t,a,r),a+=s}}decodeImaAdpcm(t,e){const{blockAlign:s,channels:r,samplesPerBlock:i}=this.format,a=Math.floor(t.byteLength/s);for(let n=0;n<a;n++){const h=n*s,l=[];let d=h;for(let f=0;f<r;f++)l.push({predictor:t.getInt16(d,this.isLittleEndian),stepIndex:t.getUint8(d+2)}),d+=4;const c=new Uint8Array(t.buffer,t.byteOffset+d,s-4*r);this.decodeImaAdpcmBlock(c,l,i,r,n*i)}}parseFormatChunk(t,e){const s=t.offset+8,r=new DataView(e.buffer,e.byteOffset,e.length);if(s+16>e.length){this.errors.push(this.createError("Format chunk too small"));return}this.format={bitsPerSample:r.getUint16(s+14,this.isLittleEndian),blockAlign:r.getUint16(s+12,this.isLittleEndian),avgBytesPerSec:r.getUint32(s+8,this.isLittleEndian),channels:r.getUint16(s+2,this.isLittleEndian),formatTag:r.getUint16(s,this.isLittleEndian),sampleRate:r.getUint32(s+4,this.isLittleEndian)},this.formatTag=this.format.formatTag,this.format.formatTag===$&&t.size>=40&&s+40<=e.length&&(this.format.channelMask=r.getUint32(s+20,this.isLittleEndian),this.format.extensionSize=r.getUint16(s+16,this.isLittleEndian),this.format.subFormat=e.subarray(s+24,s+40),this.format.validBitsPerSample=r.getUint16(s+18,this.isLittleEndian),this.formatTag=this.resolveExtensibleFormat()),this.formatTag===p?(this.bytesPerSample=0,t.size>=20&&r.getUint16(s+16,this.isLittleEndian)>=2&&(this.format.samplesPerBlock=r.getUint16(s+18,this.isLittleEndian))):this.bytesPerSample=this.format.bitsPerSample/8}processBufferedBlocks(){const{blockAlign:t}=this.format;if(this.state!==m.DECODING||!t||this.ringBuffer.available<t)return this.createEmptyResult();const s=Math.floor(this.ringBuffer.available/t)*t,r=this.ringBuffer.peekContiguous();if(r.length>=s){const l=this.decodeInterleavedFrames(r.subarray(0,s));return this.ringBuffer.discard(s),this.decodedBytes+=s,this.remainingBytes=Math.max(0,this.remainingBytes-s),l}this.decodeBuffer.byteLength<s&&(this.releaseScratchBuffer(this.decodeBuffer),this.decodeBuffer=this.getScratchBuffer(s));const i=new Uint8Array(this.decodeBuffer,0,s),a=s-r.length,n=this.ringBuffer.peek(a,r.length);i.set(r,0),i.set(n,r.length);const h=this.decodeInterleavedFrames(i);return this.ringBuffer.discard(s),this.decodedBytes+=s,this.remainingBytes=Math.max(0,this.remainingBytes-s),h}readSample(t,e,s,r){try{switch(r){case S:return this.readPcm(t,e,s);case B:return this.readFloat(t,e,s);case D:return this.readAlaw(t,e);case L:return this.readMulaw(t,e);default:return 0}}catch{return 0}}resolveExtensibleFormat(){const t=this.format.subFormat;return t?this.arraysEqual(t,rt)?S:this.arraysEqual(t,st)?B:this.format.formatTag:this.format.formatTag}tryParseHeader(){const t=this.headerBuffer;if(t.length<12)return!1;const e=new DataView(t.buffer,t.byteOffset,t.byteLength),s=u=>e.getUint32(u,this.isLittleEndian),r=u=>e.getUint32(u,!1),i=r(0);if(i!==U&&i!==V)return this.state=m.ERROR,this.errors.push(this.createError("Invalid WAV file: missing RIFF/RIFX tag")),!1;if(this.isLittleEndian=i===U,r(8)!==W)return this.state=m.ERROR,this.errors.push(this.createError("Invalid WAV file: missing WAVE tag")),!1;let a=12,n=null,h=null;const l=[];for(;a+8<=t.length;){const u=r(a),g=s(a+4);if(u===X){h={id:"data",size:g,offset:a},l.push(h);break}const b=a+8+g+g%2;if(b>t.length)return!1;let E="";u===_?E="fmt ":u===G&&(E="fact");const C={id:E,size:g,offset:a};l.push(C),u===_&&(n=C),a=b}if(!n||!h)return!1;if(this.parseFormatChunk(n,t),!this.validateFormat())return this.state=m.ERROR,!1;this.parsedChunks=l.filter(u=>["fmt ","data","fact"].includes(u.id)),this.unhandledChunks=l.filter(u=>!["fmt ","data","fact"].includes(u.id));const d=l.find(u=>u.id==="fact");d&&d.offset+12<=t.length&&(this.factChunkSamples=s(d.offset+8)),this.remainingBytes=this.totalBytes=h.size;const c=h.offset+8;this.dataStartOffset=c;const f=this.headerBuffer.subarray(c);return f.length>0&&this.ringBuffer.write(f),this.headerBuffer=new Uint8Array(0),this.state=m.DECODING,!0}readAlaw(t,e){return x()[t.getUint8(e)]??0}readFloat(t,e,s){switch(s){case 32:return Math.max(-1,Math.min(1,t.getFloat32(e,this.isLittleEndian)));case 64:return Math.max(-1,Math.min(1,t.getFloat64(e,this.isLittleEndian)));default:return 0}}readMulaw(t,e){return N()[t.getUint8(e)]??0}readPcm(t,e,s){switch(s){case 8:return(t.getUint8(e)-128)*O;case 16:return t.getInt16(e,this.isLittleEndian)*y;case 24:{if(e+3>t.byteLength)return 0;const r=t.getUint8(e),i=t.getUint8(e+1),a=t.getUint8(e+2);let n=this.isLittleEndian?a<<16|i<<8|r:r<<16|i<<8|a;return n=n<<8>>8,n*A}case 32:return t.getInt32(e,this.isLittleEndian)*P;default:return 0}}decodeImaAdpcmBlock(t,e,s,r,i){const a=e.map(c=>c.predictor),n=e.map(c=>Math.min(88,Math.max(0,c.stepIndex)));for(let c=0;c<r;c++)this.channelData[c][i]=a[c]*y;let h=1,l=0;const d=(c,f)=>{const u=it[n[f]];let g=u>>3;c&1&&(g+=u>>2),c&2&&(g+=u>>1),c&4&&(g+=u),c&8&&(g=-g),a[f]+=g,a[f]=Math.max(-32768,Math.min(32767,a[f])),n[f]=Math.min(88,Math.max(0,n[f]+at[c])),this.channelData[f][i+h]=a[f]*y};for(let c=0;c<t.length;c++){const f=t[c],u=f&15,g=f>>4,b=l%r;if(d(u,b),b===r-1&&h++,l++,h>=s)break;const E=l%r;if(d(g,E),E===r-1&&h++,l++,h>=s)break}}}export{M as W,nt as a};
